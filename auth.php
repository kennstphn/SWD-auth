<?php
/*
 * By ken sherman of shermanwebdesign.com
 * distributed under the WTFPL license by
 * Sam Hocevar
 *
 * (see http://www.wtfpl.net/)
 * 
 */
namespace SWD;

use PDO;

class auth
{
    /*
     * All usages must require a phone/gateway or email for password reset function, or workaround
     * by catching the code generated by the 2AUTH feature (see 2AUTH FEATURES)
     *
     *
     * 2AUTH FEATURES
     * There is a lock on the following fields, which must be reset via native class functions
     * -- password, phone_and_gateway, authCode,
     *
     * The capability to send the code to the end-user is NOT provided, and must be implemented outside
     * the scope of this class. Usage is get_reset_code($password, $function='string_name_of_function')
     * suggested -
     *
     *
     * "OTHER" VARIABLES
     * Any public variables that are declared are saved
     * within the JSON document, or MYSQL entry json document.
     *
     *
     * KNOWN POTENTIAL SECURITY VULNERABILITIES
     *
     * json files -- If you choose to run production off .json files, they should be encrypted and placed in a directory
     * that is non-accessible by url. Use the global $SWD->auth->storageContainers->json->savePath variable
     * to define the path
     *
     * mysql -- this is the preferred method of storage. The configuration settings in $SWD->auth are
     * certainly accessible by other scripts. If you want to eliminate opportunity for those to be used
     * to access the userFiles, keep the userFiles in a separate database, and lock that off by initiating
     * new \SWD\auth followed by immediately unsetting the global $SWD->auth variable.
     *
     *
     */
    // user details
    public $username;
    public $lastIp;
    public $status;
    public $phone_and_gateway;

    //security variables
    public $password_hash;
    public $authCode_hash; // NOTE: This is ALWAYS reset on verification, success or fail
    public $stayAlive_hash;

    //private, nonsaved variables
    private $referencePoint;
    private $authCode_reset_isCleared;
    private $password_reset_isCleared;
    private $phone_and_gateway_reset_isCleared;
    private $db;

    // Private config settings.
    // DEFAULTS ARE SET HERE
    // These are set via the optional $SWD->auth global object
    private $storageContainers;

    //dynamically created, public variables
    /*
     * $this->saveLog
     */
    
    function __construct(){

        /*
         * DEFAULTS
         */

        $this->storageContainers = (object)[
            'json'=> (object)[
                'enabled'=>true,
                'savePath'=>$this->confirm_trailing_slash(dirname( __FILE__) . '/userFiles'),
                'loggingIsEnabled' => true
            ],
            'mysql'=>(object)[
                'enabled' => false,
                'db_host' => '',
                'db_port' => '',
                'db_name' => '',
                'db_user' => '',
                'db_pass' => '',
                'table'   => '',
                'loggingIsEnabled' => false,
                'log_table'     => ''
            ],
            'custom'=>(object)[
                'enabled'=>false,
                'functionName'=>null
            ]
        ];


        /*
         * 
         * OVERRIDE DEFAULT SETTINGS HERE
         * (dynamically via the $SWD->auth object)
         * 
         * this iterates over all globally declared auth settings and sets
         * the local variants to those values. 
         */
        global $SWD;

        if(
            is_object($SWD)
            && is_object($SWD->auth)
        ){
            
            foreach ($SWD->auth as $propertyName => $setting){
                $propertyNameSanitized = $this->conform_characters($propertyName);
                $settingSanitized = $this->conform_characters($setting);
                $this->$propertyNameSanitized = $settingSanitized;

            }

        }

        /*
         * 
         * DECLARE STATIC CONFIGS HERE
         * 
         * Any non-overrideable settings should be (re)declared here
         * as the previous section provided access to overwriting 
         * everything via the $SWD->auth object
         */

        // unset the isCleared variables. Use case is minimalx, would require
        // another script changing the storage data.
        unset(
            $this->referencePoint,
            $this->password_reset_isCleared,
            $this->authCode_reset_isCleared,
            $this->phone_and_gateway_reset_isCleared
        );

        // for ease of use, lets just ensure that we didn't forget
        // the trailing slash at the end of the savePath
        $this->storageContainers->json->savePath = $this->confirm_trailing_slash($this->storageContainers->json->savePath);

        // create the json storage directory as needed.
        if (! is_dir($this->storageContainers->json->savePath)){
            mkdir($this->storageContainers->json->savePath);
        }

        //prep the mysql connection as needed
        if ($this->storageContainers->mysql->enabled){

            $this->prep_mysql_connection();
        }
        
    }
    
    function create_new_user($username, $password){
        if ($this->check_if_user_exists($username)){
            // this user already exists!
            throw new \Exception('A user by this name already exists', 1);
        }

        $this->username = $username;
        $this->password_hash = password_hash($password, PASSWORD_DEFAULT);

        return $this->save();
    }

    function authenticate($username){

        $userFile = $this->get_userFile_from_storage($username);

        /*
         * Authenticate against password
         */
        if (
        array_key_exists('password', $_POST)
        ){
            // Authenticate as login
            if (! $this->login($userFile)){
                return false;
            }

            //logged in, so load userFile to properties
            $this->load_userFile($userFile);

            //update last login info, reset cookie auth hash
            $this->set_cookie_auth();
            $this->lastIp = $_SERVER['REMOTE_ADDR'];
            $this->save();

            $authenticated = true;
        }

        /*
         * authenticate against cookie + ip
         */
        if (
            array_key_exists('stayAlive', $_COOKIE)
            && ! array_key_exists('username',$_POST )
            && ! array_key_exists('password', $_POST)
        ){
            //compare posted username / password to file
            if (! $this->login_via_cookie($userFile)){
                return false;
            }

            //logged in, so load userFile to properties
            $this->load_userFile($userFile);

            /*
             * overwrite the $_COOKIE['stayAlive'] comp hash
             * and the lastIp reference point
             */

            $this->set_cookie_auth();

            //set lastIp
            $this->lastIp = $_SERVER['REMOTE_ADDR'];

            $this->save();

            $this->create_reference_point();
            $authenticated = true;
        }


        //todo New Feature:
        /*
         * Consider supporting alternate passwords for account that grant read access only
         *
         */


        if ( isset($authenticated) && $authenticated == true){
            $this->create_reference_point();
            return $this;
        }

        // reject login if no white-listed case exists
        return false;
    }

    function set_new_password($newPassword, $oldPassword, $authCode){
        
        // check old password
        if (! password_verify($oldPassword, $this->password_hash) ){ return false;}
        
        // check authorization code
        // NOTE that this resets the authCode
        if ($this->verify_reset_code($authCode) != true){
            return false;
        }
        
        //otherwise, clear to proceed
        $this->password_reset_isCleared = true;
        
        // change password and save it.
        $this->password_hash = password_hash($newPassword, PASSWORD_DEFAULT);
        $this->save();
        
        return true;
        
    }

    function get_reset_code($password, $function_that_handles_gateway_and_code){

        $success = password_verify($password, $this->password_hash );
        if (! $success){
            return false;
        }
        
        
        
        //we have access via pwd to account
        
        //create and set
        $code = rand(100000,999999);
        $this->authCode_hash = password_hash($code, PASSWORD_DEFAULT);

        //save hashed authCode
        if( ! $this->save() ){
            return false;
        }

        $function_that_handles_gateway_and_code($this->phone_and_gateway,$code);
        return true;
    }

    function update_phone_and_gateway($phone_and_gateway, $authCode = null){

        //Initial set up
        if (
            $this->phone_and_gateway == null    // never been set, or has been manually cleared
        ){
            $this->phone_and_gateway = $phone_and_gateway;
            $this->phone_and_gateway_reset_isCleared = true;

            return $this->save();
        }

        //check #1
        if (
            $this->phone_and_gateway != null    //gateway is already set
            && $authCode == null                //  & no code provided
        ){
            throw new \Exception('Auth code must be provided to update phone and gateway');
        }

        if(
            $this->phone_and_gateway!= null     //gatway is already set
            && $authCode != null                // auth code is provided
            && $this->verify_reset_code($authCode) != true
        ){

            throw new \Exception('Authorization code provided did not match. Please request a new code and try again');

        }

        if(
            $this->phone_and_gateway!= null     //gatway is already set
            && $authCode != null                // auth code is provided
            && $this->verify_reset_code($authCode) == true
        ){
            $this->phone_and_gateway = $phone_and_gateway;
            $this->phone_and_gateway_reset_isCleared = true;
            return $this->save();
        }

        return false;       // not sure how we got here in this case...

    }

    function save($logThisAction = true){
        
        // get the name of the calling function
        $callingFunction = debug_backtrace()[1]['function'];

        
        //make sure that the updates aren't added externally through the non-official pathways
        if (
            $callingFunction != 'authenticate'                //we save datapoints on authentication
            && $callingFunction != 'create_new_user'  //kinda need to add initialization through
            && $this->clear_updates() != true
        ){
            return false;
        }
        
        // NOTE: logThisAction overrides the global SWD->auth->json/mysql/custom->loggingIsEnabled variable
        if ($logThisAction){
            $this->add_action_to_saveLog($callingFunction);
        }

        //bugfixing $mysql insert vs update
        $update = true;
        if ($callingFunction == 'create_new_user'){$update = false;}
        $success = $this->put_userFile_in_storage($update);

        return $success;
    }

    private function add_action_to_saveLog($callingFunction){
        //create the date for the log
        date_default_timezone_set('UTC');
        $date = date('Y-m-d--H-i-s');

        // if saveLog doesn't exist, create it as an empty array
        if (! isset($this->saveLog) || ! is_array($this->saveLog)){
            $this->saveLog = array();
        }

        // ensure no nesting of logs occurs
        $saveLogHolder = $this->saveLog;
        unset($this->saveLog);

        // push the new log into the saveLog
        array_merge(
            $saveLogHolder,
            array( 
                'change source' => $callingFunction,
                $date => json_encode($this) 
            )
        );

        $this->saveLog = $saveLogHolder;

    }

    private function clear_updates(){
        
        //clear the edits to ensure no security disabling code has been implemented

        $reference = json_decode($this->referencePoint);

        if ($this->password_hash != $reference->password_hash && $this->password_reset_isCleared != true){
            return false;
        }

        if ($this->authCode_hash != $reference->authCode_hash && $this->authCode_reset_isCleared != true){
            return false;
        }

        if ($this->phone_and_gateway != $reference->phone_and_gateway && $this->phone_and_gateway_reset_isCleared != true){
            return false;
        }

        return true;
    }
    
    private function set_cookie_auth(){
        //get a random string
        $random = password_hash(rand(10000000,99999999), PASSWORD_DEFAULT);
        $random = str_split($random, 8);

        //set cookie
        setcookie('stayAlive', $random[0]);

        //set stayAlive local hash
        $this->stayAlive_hash = password_hash($random[0], PASSWORD_DEFAULT);
    }

    private function login_via_cookie($userFile){

        if (! password_verify($_COOKIE['stayAlive'], $userFile)->stayAlive_hash){
            return false;
        }

        return true;
    }

    private function load_userFile($userFile){
        foreach ($userFile as $propertyName => $value){
            $this->$propertyName = $value;
        }
    }

    private function login($userFile){
        if (! password_verify($_POST['password'], $userFile->password_hash)){
            return false;
        }

        return true;

    }

    private function check_if_user_exists($username = null){
        if ($username == null){
            $username = $this->username;
        }
        
        if ($username == null){
            throw new \Exception('username not given for check_if_user_exists');
        }
        
        //check if file exists
        if (
            $this->storageContainers->json->enabled == true &&
            file_exists($this->storageContainers->json->savePath . $username . '.json') == true
        ){
            return true;
        }

        $query = $this->db->prepare("SELECT username FROM ".$this->storageContainers->mysql->table." WHERE username = :username");
        $query->execute(array(':username'=>$username));

        if(
            $this->storageContainers->mysql->enabled == true &&
            $query->fetch() != false //false means no user exists
        ){
            return true;
        }

        return false;
    }

    private function confirm_trailing_slash($savePath){

        //ensure trailing slash
        if ( strrpos($savePath,'/') + 1 != strlen($savePath) ){
            $savePath = $savePath . '/';
        }

        return $savePath;

    }

    private function create_reference_point(){
        $this->referencePoint = json_encode($this);
    }
    
    private function get_userFile_from_storage($username){
        $userFileArray = array();
        if($this->storageContainers->json->enabled){
            array_push($userFileArray, $this->get_json_userFile_from_storage($username));
        }
        
        if ($this->storageContainers->mysql->enabled){
            array_push($userFileArray, $this->get_mysql_userFile_from_storage($username));
        }

        if (
            isset($this->storageContainers->custom) &&
            $this->storageContainers->custom->enabled
        ){
            array_push($userFileArray, $this->storageContainers->custom->functionName($username));
        }
        
        if (! count($userFileArray)){
            return false;
        }

        //Compare the userFiles, ignoring the saveLog field. 
        $jsonArray = $compare = $userFileArray[0];
        unset($compare->saveLog);
        foreach($userFileArray as $index => $userFile){
            if ($index != 0){
                //don't compare saveLogs
                unset($userFile->saveLog);
                if(json_encode($compare) != json_encode($userFile)){throw new \Exception('out of sync userFiles');}
            }
        }

        
        return $compare;
        
    }
    
    private function get_mysql_userFile_from_storage($username){
        $sql = "SELECT userfile FROM ". $this->storageContainers->mysql->table ." WHERE username = :username";
        $query = $this->db->prepare($sql);
        $params = array(
            ':username'=>$username
        );
        $query->execute($params);

        $userFile = $query->fetch(PDO::FETCH_OBJ)->userfile;
        
        return json_decode($userFile);
    }
    
    private function get_json_userFile_from_storage($username){
        if($this->does_json_user_exist($username) != true){
            return false;
        }
        
        $userFile = json_decode(file_get_contents($this->storageContainers->json->savePath.$username.'.json'));
        return $userFile;
    }
    
    private function does_json_user_exist($username){
        if (file_exists($this->storageContainers->json->savePath . $username . '.json')){
            return true;
        }
        return false;
    }
    
    private function put_userFile_in_storage($update){
        //unless we try these and fail,
        //they won't block "success" in this function
        $jsonSuccess = $mysqlSuccess = $customSuccess = 1;
        
        if ( $this->storageContainers->json->enabled ){
            $jsonSuccess = $this->put_userFile_in_json_storage($this);
        }
        
        if ($this->storageContainers->mysql->enabled ){
            $mysqlSuccess = $this->put_userFile_in_mysql_storage($this, $update);
        }
        
        if(isset($this->storageContainers->custom) && $this->storageContainers->custom->enabled){
            $customSuccess = $this->storageContainers->custom->functionName($this);
        }
        
        if($jsonSuccess && $mysqlSuccess && $customSuccess){
            return true;
        }
        
        throw new \Exception('Storage of userFile failed. Code is '.$jsonSuccess .'-'.$mysqlSuccess.'-'.$customSuccess);

    }

    private function put_userFile_in_json_storage($userFile){

        // clear the saveLog as needed
        if ($this->storageContainers->json->loggingIsEnabled == false){
            unset($userFile->saveLog);
        }

        $success =  file_put_contents(
            $this->storageContainers->json->savePath . $this->username . '.json',
            json_encode($userFile)
        );
        
        if(!$success){
            return 0;
        }
        
        return 1;
    }

    private function verify_reset_code($code){

        //verify password
        $bool_verified = password_verify($code,$this->authCode_hash);

        //authCode is always reset
        unset($this->authCode_hash);
        $this->save();

        return $bool_verified;
    }

    private function put_userFile_in_mysql_storage($userFile, $update = true){
        
        /*
         * MYSQL storage expects a table with columns named
         * "username" and "userfile"
         * with "username" having a key (unique or primary)
         * 
         * MYSQL->LOGGING expects a table with a column called 
         * "entry" that is not keyed. 
         * 
         * If you want a different setup, I suggest using a callback
         * function. Look at comments in "put_userFile_in_storage" for 
         * details
         * 
         */
        $log = null;

        // if loggingIsEnabled, we need to populate the log variable before we clear the userFile->saveLog
        if($this->storageContainers->mysql->loggingIsEnabled == true){
            $log = $userFile->saveLog;
        }

        //clear the saveLog, because even if we're storing it, it's going somewhere else
        unset($userFile->saveLog);

        /*
         * Store the userFile
         */
        $sql = "UPDATE ".$this->storageContainers->mysql->table." SET userfile = :userfile WHERE username = :username";
        // Insert the userFile
        if($update == false) {
            $sql = "INSERT INTO " . $this->storageContainers->mysql->table . " (username, userfile) VALUES (:username, :userfile)";
        }
        $query = $this->db->prepare($sql);
        $params = array(
            ':username'=>$userFile->username,
            ':userfile'=>json_encode($userFile)
        );

        $userFileSuccess = $query->execute($params);

        //do the below section if mysql logging is enabled. 
        switch($this->storageContainers->mysql->loggingIsEnabled){
            case true:
                //insert the log file
                $sql = "INSERT INTO ".$this->storageContainers->mysql->log_table." (entry) VALUES (:entry) ";
                $query = $this->db->prepare($sql);
                $params = array(
                    ':entry'=>json_encode($log)
                );
                $logSuccess = $query->execute($params);
                break;
            default:
                $logSuccess = true;
        }
        
        if($logSuccess && $userFileSuccess){
            return 1;
        }
        
        return 0;
    }
    
    private function prep_mysql_connection(){
        // PDO db connection statement preparation
        $dsn = 'mysql:host=' . $this->storageContainers->mysql->db_host .
            ';dbname='    . $this->storageContainers->mysql->db_name .
            ';port=' . $this->storageContainers->mysql->db_port;

        // note the PDO::FETCH_OBJ, returning object ($result->id) instead of array ($result["id"])
        // @see http://php.net/manual/de/pdo.construct.php
        $options = array(PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_OBJ, PDO::ATTR_ERRMODE => PDO::ERRMODE_WARNING);

        // create new PDO db connection
        $this->db = new PDO(
            $dsn,
            $this->storageContainers->mysql->db_user,
            $this->storageContainers->mysql->db_pass,
            $options
        );
    }

    private function conform_characters($string){
        if(! is_string($string)){return $string;}
        preg_match_all('/[a-zA-Z]/', $string, $matches);
        $sanitizedString = implode('', $matches[0] );
        return $sanitizedString;
    }
}
